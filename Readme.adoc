= REACT - Fragments, Portal & Refs

== JSX Limitations
*You can't return more than one "root JSX element* You can't store more than one "root" JSX element in a variable

Instead a wrapping <div> we also can return an array:

[source]
----
 return (
    <div>
      <div className={classes.backdrop} onClick={props.onConfirm} />
      <Card className={classes.modal}>
        <header className={classes.header}>
          <h2>{props.title}</h2>
        </header>
        <div className={classes.content}>
          <p>{props.message}</p>
        </div>
        <footer className={classes.actions}>
          <Button onClick={props.onConfirm}>Okay</Button>
        </footer>
      </Card>
    </div>
  );
----

Using an array instead a wrapping <div>:
[source]
----
 return (
    [
      <div className={classes.backdrop} onClick={props.onConfirm} />,   //Separate each element inside the array by commas
      <Card className={classes.modal}>,   //Separate each element inside the array by commas
        <header className={classes.header}>
          <h2>{props.title}</h2>
        </header>
        <div className={classes.content}>
          <p>{props.message}</p>
        </div>
        <footer className={classes.actions}>
          <Button onClick={props.onConfirm}>Okay</Button>
        </footer>
      </Card>
    ]
  );
----

With this approach React will complains for a key for each element, so the solution will be add a key in each element of the array:
[source]
----
 return (
    [
      <div key="div-wrapper" className={classes.backdrop} onClick={props.onConfirm} />,   
      <Card key="card-element" className={classes.modal}>,  
----

=== DIV soup
With this DIV wrapping approach, we could end up with DIV SOUP.
Many nested React components, many unnecessary DIVs being rendered in the real DOM, only due to the JSX limitation commented before.
In bigger apps, you can easily end up with tons of unnecessary <div>s (or other elements) *which add no semantic meaning or structure* to the page but are only there because of React's/ JSX requirement.
Render a lot of HTML element could make the application slower, also because React need to be aware of any change in those elements.

==== Wrapping component
Creating a wrapper component, Will just return the content within the enclosed wrapper.
The *props.children* will hold all the content inside the wrapper.

[source]
----
const Wrapper = props => {
  return props.children;
}

export default Wrapper;
----

With this approach *No additional, unnecessary DIVs are rendered in the real DOM*

=== React FRAGMENTS 
React Fragment is an empty wrapper component, It doesn't render any real HTML element to the DOM. But it fulfills React's/JSX' requirement.
React.Fragment can be used as a wrapper, via these syntaxies:
[source]
----
return (
  <React.Fragment>
    <h2>Hi there!</h2>
    <p>Another element</p> 
  </React.Fragment>
)
----
Or
This syntax requires to be supported by the build setup in your environment.
[source]
----
return (
  <>
    <h2>Hi there!</h2>
    <p>Another element</p> 
  </>
)
----

== Portals
The problem with a modal, *Semantically* and from a _clean HTML structure_ perspective, having this nested maodal isn't ideal it is an *overlay to the entire page* after all (thatÂ´s similar for side-drawers, other dialogs, etc.).

It's a bit like styling a <div> like a <button> and adding an event listener to it: It'll work, but it's not a good practice.
_<div onClick={clickHandler}>Click me, I'm a bad button</div>

Import ReactDOM:
_import ReactDOM from 'react-dom';_

Put divs otuside the root element, where you want the React element be translated, be _portaled_
file: _index.html_
[source,html]
----
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="backdrop-root"></div>
    <div id="overlay-root"></div>
    <div id="root"></div>
----

*You can make things works, but just because it works doesn't means is a good implementation*

== React Refs
Ref is a property(as key property)can be used in any HTML element
You can connect any of the HTML element to one of Refs(many common in input elements becaus you want fetch input data)

In order to user Ref, import the useRef() hook from React
Real DOM element will be stored in the variable defined by the useRef()

[source]
----
import { useRef } from 'react';

const nameInputRef = useRef();
const ageInputRef = useRef();

// And in the HTML element:
<input
    id="username"
    type="text"
    value={enteredUsername}
    onChange={usernameChangeHandler}
    ref={nameInputRef}
  />
----

The ref always is an object, and always has a _current_ prop, and such _current_ prop hold the actual value wich ref is connected.
What is stored is the actual DOM node.

*When to use refs?* 
If you just want to *READ VALUES* ref could be a better option than useState()

=== Controlled and Uncontrolled components
*Uncontrolled* components: they internal state is not controlled by React.
Input components, Form components in general are commonly *Uncontrolled* components 

*Controlled* components, the value of the components is managed by react, via the useState methods and the two-binding (setting the value in the input).

