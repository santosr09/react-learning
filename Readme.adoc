= REACT - Effects, Reducers & Context

== Managing more complex state with Reducers
Sometimes you have *more complex state* - for example if it got *multiple states, multiple ways of changing it or dependencies* to other states.

useState() then often *becomes hard or error-prone to use* - it's easy to write bad, inefficient or buggy code in such escenarios.

*useReducer()* can be used as a *replacement* for useState() if you need *more powerful state management*.

_Some uses cases when to use useReducer():_
When yuo have states that belong together.
If you have state updates that depends on other state.

=== Understanding useReducer()

*const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);*

useReducer() always returns an array with exactly two values.

state:
The state snapshot used in the component re-render/ re-evaluation cycle

dispatchFn:
A function that can be used to dispatch a new action(i.e. trigger an update of the state)

reducerFn:
(prevState, action) => newState
A function that is *triggered automatically* once an action is *dispatched* (via dispatchFn()) - it *receives the latest state snapshot* and should *return the new, updated state*

initialState:
The initial state

initFn:
A function to set the initial state programmatically

=== Alias assignment (when destructuring)
Normal destructuring
const { isValid } = emailState

Destructuring with Alias assignment.
const { isValid: passwordIsValid } = emailState
passwordIsValid is the 'alias' for the field isValid

==== Adding Nested Properties As Dependencies To useEffect
_We used object destructuring to add object properties as dependencies to useEffect()._
[source, javascript]
----
const { someProperty } = someObject;
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);
----
_This is a very common pattern and approach, which is why I typically use it and why I show it here (I will keep on using it throughout the course)._

_I just want to point out, that they key thing is NOT that we use destructuring but that we pass specific properties instead of the entire object as a dependency._

_We could also write this code and it would work in the same way._

[source, javascript]
----
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);
----
_This works just fine as well!_

_But you should avoid this code:_
[source, javascript]
----
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject]);
[source, javascript]
----
_Why?_
_Because now the effect function would re-run whenever ANY property of someObject changes - not just the one property (someProperty in the above example) our effect might depend on._

=== useState() Vs useReducer()
Generally you'll know when you need useReducer() -> when using useState()  becomes cumbersome or you're getting a lot of bugs/ unintended behaivors

* useState():
** The main state management 'tool'
** Great for independent pieces of state/data
** Great if state updates are easy and limited to a few kinds of updates

* useReducer():
** Great if you need more 'power' (complex state, use reducer alwasy guarantee your working wiht latest snapshoot of state)
** Should be considered if you have related pieces of state/data 
** Can be helpful if you have more complex state updates


== Managing App-Wide or Component-Wide State with Context

https://reactjs.org/docs/context.html
Context provides a way to pass data through the component tree without having to pass props down manually at every level.

In a typical React application, data is passed top-down (parent to child) via props, but such usage can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.

Context is primarily used when some data needs to be accessible by many components at different nesting levels. Apply it sparingly because it makes component reuse more difficult.

If you only want to avoid passing some props through many levels, *component composition* is often a simpler solution than context.

=== API context
*React.createContext*
[source]
----
const MyContext = React.createContext(defaultValue);
----

*Context.Provider*
[source]
----
<MyContext.Provider value={/* some value */}>
----

*Class.contextType*
[source]
----
class MyClass extends React.Component {
  componentDidMount() {
    let value = this.context;
    /* perform a side-effect at mount using the value of MyContext */
  }
  componentDidUpdate() {
    let value = this.context;
    /* ... */
  }
  componentWillUnmount() {
    let value = this.context;
    /* ... */
  }
  render() {
    let value = this.context;
    /* render something based on the value of MyContext */
  }
}
MyClass.contextType = MyContext;
----

*Context.Consumer*
[source]
----
<MyContext.Consumer>
  {value => /* render something based on the context value */}
</MyContext.Consumer>
----

=== Using context: 1. Providing the context

Providing means that you wrap in JSX code all the components that should be able to tap into that Context, that should be able to listen to that context. Any component that's not wrapped will not be able to listen.

[source]
----
      <AuthContext.Provider>
      <MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} />
      <main>
        {!isLoggedIn && <Login onLogin={loginHandler} />}
        {isLoggedIn && <Home onLogout={logoutHandler} />}
      </main>
      </AuthContext.Provider>
----
All the components wrapped by AuthContext, will have access to AuthContext (All the components and their descendents.)

We can listen the context in 2 ways: By using AuthContext consumer or by using a React Hook

Example of listening the context using a consumer:
[source]
----
const Navigation = (props) => {

  return (
    <AuthContext.Consumer>
      { (ctx) => {
        return (
        <nav className={classes.nav}>
          <ul>
            {ctx.isLoggedIn && (
              <li>
                <a href="/">Users</a>
              </li>
            )}
            {ctx.isLoggedIn && (
              <li>
                <a href="/">Admin</a>
              </li>
            )}
            {ctx.isLoggedIn && (
              <li>
                <button onClick={props.onLogout}>Logout</button>
              </li>
            )}
          </ul>
        </nav>
        )
      }
      }
    </AuthContext.Consumer>
  );
};

export default Navigation;

----

=== useContext Hook
[source]
----
import {useContext} from 'react';
const Navigation = (props) => {
  const ctx = useContext(AuthContext);
----

In most cases you will use props to pass data to components
Because props are your mechanism to configure components and to make them reusable.

== CONTEXT LIMITATIONS
It can be great for app-wide or component-wide state. States that affects multiple components.
It's Not a replacement for component configuration

****
*PROPS FOR CONFIGURATION*
*CONTEXT FOR STATE MANAGEMENT ACROSS COMPONENTS*
****

React Context is *NOT optimized* for high frequency changes! (better tool: Redux)

React Context also *shouldn't be used to replace ALL* component communications and props.
Components should still be configurable via props and short "prop chain" might not need any replacement.

== RULES OF HOOKS

* Only call React Hooks in *React Functions*
** React Component Functions
** Custom Hooks.

* Only call React Hooks at the *Top Level*
** Don't call them in nested functions
** Don't call them in any block statements

Extra, _unofficial_ Rule for *useEffect()*: ALWAYS add everything you refer to inside of useEffect() as a dependency!

== Forward Refs
https://reactjs.org/docs/forwarding-refs.html
Ref forwarding is an opt-in feature that lets some components take a ref they receive, and pass it further down (in other words, “forward” it) to a child.

In the example below, FancyButton uses React.forwardRef to obtain the ref passed to it, and then forward it to the DOM button that it renders:

[source]
----
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// You can now get a ref directly to the DOM button:
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
----

This way, components using FancyButton can get a ref to the underlying button DOM node and access it if necessary—just like if they used a DOM button directly.

Here is a step-by-step explanation of what happens in the above example:

. We create a React ref by calling React.createRef and assign it to a ref variable.
. We pass our ref down to <FancyButton ref={ref}> by specifying it as a JSX attribute.
. React passes the ref to the (props, ref) => ... function inside forwardRef as a second argument.
. We forward this ref argument down to <button ref={ref}> by specifying it as a JSX attribute.
. When the ref is attached, ref.current will point to the <button> DOM node.

=== useImperativeHandle Hook
https://reactjs.org/docs/hooks-reference.html#useimperativehandle
[source]
----
useImperativeHandle(ref, createHandle, [deps])
----

useImperativeHandle customizes the instance value that is exposed to parent components when using ref. As always, imperative code using refs should be avoided in most cases. useImperativeHandle should be used with forwardRef:
[source]
----
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);
----

In this example, a parent component that renders <FancyInput ref={inputRef} /> would be able to call inputRef.current.focus().

