= REACT - Effects, Reducers & Context

== Managing more complex state with Reducers
Sometimes you have *more complex state* - for example if it got *multiple states, multiple ways of changing it or dependencies* to other states.

useState() then often *becomes hard or error-prone to use* - it's easy to write bad, inefficient or buggy code in such escenarios.

*useReducer()* can be used as a *replacement* for useState() if you need *more powerful state management*.

_Some uses cases when to use useReducer():_
When yuo have states that belong together.
If you have state updates that depends on other state.

=== Understanding useReducer()

*const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);*

useReducer() always returns an array with exactly two values.

state:
The state snapshot used in the component re-render/ re-evaluation cycle

dispatchFn:
A function that can be used to dispatch a new action(i.e. trigger an update of the state)

reducerFn:
(prevState, action) => newState
A function that is *triggered automatically* once an action is *dispatched* (via dispatchFn()) - it *receives the latest state snapshot* and should *return the new, updated state*

initialState:
The initial state

initFn:
A function to set the initial state programmatically

=== Alias assignment (when destructuring)
Normal destructuring
const { isValid } = emailState

Destructuring with Alias assignment.
const { isValid: passwordIsValid } = emailState
passwordIsValid is the 'alias' for the field isValid

==== Adding Nested Properties As Dependencies To useEffect
_We used object destructuring to add object properties as dependencies to useEffect()._
[source, javascript]
----
const { someProperty } = someObject;
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);
----
_This is a very common pattern and approach, which is why I typically use it and why I show it here (I will keep on using it throughout the course)._

_I just want to point out, that they key thing is NOT that we use destructuring but that we pass specific properties instead of the entire object as a dependency._

_We could also write this code and it would work in the same way._

[source, javascript]
----
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);
----
_This works just fine as well!_

_But you should avoid this code:_
[source, javascript]
----
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject]);
[source, javascript]
----
_Why?_
_Because now the effect function would re-run whenever ANY property of someObject changes - not just the one property (someProperty in the above example) our effect might depend on._

=== useState() Vs useReducer()
Generally you'll know when you need useReducer() -> when using useState()  becomes cumbersome or you're getting a lot of bugs/ unintended behaivors

* useState():
** The main state management 'tool'
** Great for independent pieces of state/data
** Great if state updates are easy and limited to a few kinds of updates

* useReducer():
** Great if you need more 'power' (complex state, use reducer alwasy guarantee your working wiht latest snapshoot of state)
** Should be considered if you have related pieces of state/data 
** Can be helpful if you have more complex state updates


== Managing App-Wide or Component-Wide State with Context

